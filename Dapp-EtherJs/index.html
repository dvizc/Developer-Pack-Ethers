<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethers.js DApp</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        max-width: 800px;
        margin: 50px auto;
        padding: 20px;
      }
      .section {
        margin: 20px 0;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }
      button {
        background-color: #4CAF50;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }
      button:hover {
        background-color: #45a049;
      }
      #disconnectBtn {
        background-color: #f44336;
      }
      #disconnectBtn:hover {
        background-color: #da190b;
      }
      #revokeBtn {
        background-color: #ff6b6b;
      }
      #revokeBtn:hover {
        background-color: #ff5252;
      }
      input {
        padding: 8px;
        margin: 5px;
        width: 400px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .result {
        margin-top: 10px;
        padding: 10px;
        background-color: #f0f0f0;
        border-radius: 4px;
        font-family: monospace;
        white-space: pre-wrap;
        word-break: break-all;
      }
    </style>
  </head>
  <body>
    <h1>Ethers.js DApp - Blockchain Explorer</h1>

    <!-- Conexi√≥n de Wallet -->
    <div class="section">
      <h2>üîó Wallet Connection</h2>
      <div id="wallet">Connecting...</div>
      <div id="network" class="result" style="margin: 10px 0;"></div>
      <div style="margin-top: 10px;">
        <button id="disconnectBtn" onclick="disconnectWallet()" style="display: none;">
          üîå Disconnect from App
        </button>
        <button id="revokeBtn" onclick="revokePermissions()" style="display: none;">
          üö´ Revoke MetaMask Permissions
        </button>
      </div>
    </div>

    <!-- Consulta de Blockchain -->
    <div class="section">
      <h2>üîç Blockchain Query</h2>
      <button onclick="getCurrentBlock()">Get Current Block Number</button>
      <div id="blockResult" class="result"></div>
    </div>

    <!-- Consulta de Balance -->
    <div class="section">
      <h2>üí∞ ETH Balance Query</h2>
      <input type="text" id="addressInput" placeholder="Enter Ethereum address (0x...)">
      <button onclick="getBalance()">Get Balance</button>
      <div id="balanceResult" class="result"></div>
    </div>

    <!-- Saldo de USDC -->
    <div class="section">
      <h2>üíµ USDC Balance</h2>
      <button onclick="getUSDCBalance()">Get My USDC Balance</button>
      <div id="usdcBalanceResult" class="result"></div>
    </div>

    <!-- Transferir USDC -->
    <div class="section">
      <h2>üí∏ Transfer USDC</h2>
      <input type="text" id="receiverAddress" placeholder="Receiver address (0x...)">
      <input type="number" id="usdcAmount" placeholder="Amount (e.g., 10.5)" step="0.000001">
      <button onclick="transferUSDC()">Transfer USDC</button>
      <div id="transferResponse" class="result" style="display: none;"></div>
    </div>

    <!-- Firmar Mensaje -->
    <div class="section">
      <h2>‚úçÔ∏è Sign Message</h2>
      <input type="text" id="messageInput" placeholder="Enter message to sign">
      <button onclick="signMessage()">Sign Message</button>
      <div id="signatureResult" class="result"></div>
    </div>

    <script type="module">
      import { ethers } from './node_modules/ethers/dist/ethers.js';

      // USDC Contract Configuration
      const usdcAddresses = {
        '1': '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',        // Mainnet
        '11155111': '0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238', // Sepolia
        '5': '0x07865c6E87B9F70255377e024ace6630C1Eaa37F'         // Goerli
      };

      const usdcABI = [
        "function name() view returns (string)",
        "function symbol() view returns (string)",
        "function decimals() view returns (uint8)",
        "function balanceOf(address _owner) public view returns (uint256 balance)",
        "function transfer(address _to, uint256 _value) public returns (bool success)",
      ];

      // Variables globales
      let provider;
      let signer;
      let userAddress;

      // Inicializaci√≥n
      (async function () {
        if (!window.ethereum) {
          document.getElementById("wallet").innerText = "‚ùå Please install MetaMask!";
          return;
        }

        provider = new ethers.BrowserProvider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = await provider.getSigner();
        
        userAddress = await signer.getAddress();
        document.getElementById("wallet").innerText = "‚úÖ Connected: " + userAddress;

        const network = await provider.getNetwork();
        console.log("Network Info:", network);
        console.log("Chain ID:", network.chainId);
        
        const networkNames = {
          '1': 'Ethereum Mainnet',
          '11155111': 'Sepolia Testnet',
          '5': 'Goerli Testnet',
          '137': 'Polygon Mainnet'
        };
        
        const displayName = networkNames[network.chainId.toString()] || network.name;
        document.getElementById("network").innerText = 
          `üåê Network: ${displayName} (Chain ID: ${network.chainId})`;

        document.getElementById("disconnectBtn").style.display = "inline-block";
        document.getElementById("revokeBtn").style.display = "inline-block";

        window.getCurrentBlock = getCurrentBlock;
        window.getBalance = getBalance;
        window.signMessage = signMessage;
        window.disconnectWallet = disconnectWallet;
        window.revokePermissions = revokePermissions;
        window.getUSDCBalance = getUSDCBalance;
        window.transferUSDC = transferUSDC;
        window.provider = provider;
        window.signer = signer;
        window.ethers = ethers;
      })();

      async function getCurrentBlock() {
        try {
          let currentBlock = await provider.getBlockNumber();
          console.log("Current block:", currentBlock);
          document.getElementById("blockResult").innerText = 
            `Current Block Number: ${currentBlock}`;
        } catch (error) {
          console.error("Error getting block:", error);
          document.getElementById("blockResult").innerText = 
            `Error: ${error.message}`;
        }
      }

      async function getBalance() {
        try {
          let address = document.getElementById("addressInput").value;
          
          if (!address) {
            address = userAddress;
            console.log("No address provided, using connected wallet:", address);
          }

          if (!ethers.isAddress(address)) {
            document.getElementById("balanceResult").innerText = 
              "Invalid Ethereum address";
            return;
          }

          console.log("Querying balance for:", address);
          let balance = await provider.getBalance(address);
          console.log("Balance in Wei:", balance.toString());
          
          let balanceInEth = ethers.formatEther(balance);
          console.log("Balance in ETH:", balanceInEth);
          
          const network = await provider.getNetwork();
          
          document.getElementById("balanceResult").innerText = 
            `Address: ${address}\nBalance: ${balanceInEth} ETH\nNetwork: ${network.name} (Chain ID: ${network.chainId})`;
        } catch (error) {
          console.error("Error getting balance:", error);
          document.getElementById("balanceResult").innerText = 
            `Error: ${error.message}`;
        }
      }

      async function signMessage() {
        try {
          let message = document.getElementById("messageInput").value;
          
          if (!message) {
            document.getElementById("signatureResult").innerText = 
              "Please enter a message to sign";
            return;
          }

          let signature = await signer.signMessage(message);
          
          console.log("Message:", message);
          console.log("Signature:", signature);
          
          document.getElementById("signatureResult").innerText = 
            `Message: "${message}"\n\nSignature:\n${signature}`;
        } catch (error) {
          console.error("Error signing message:", error);
          document.getElementById("signatureResult").innerText = 
            `Error: ${error.message}`;
        }
      }

      async function getUSDCBalance() {
        try {
          const network = await provider.getNetwork();
          const chainId = network.chainId.toString();
          
          console.log("Current Chain ID:", chainId);
          
          const usdcAddress = usdcAddresses[chainId];
          
          if (!usdcAddress) {
            document.getElementById("usdcBalanceResult").innerText = 
              `‚ö†Ô∏è USDC not available on this network (Chain ID: ${chainId})\n\n` +
              `Available networks:\n` +
              `- Ethereum Mainnet (Chain ID: 1)\n` +
              `- Sepolia Testnet (Chain ID: 11155111)\n` +
              `- Goerli Testnet (Chain ID: 5)`;
            return;
          }

          const usdcContract = new ethers.Contract(usdcAddress, usdcABI, signer);
          
          console.log("USDC Contract Address:", usdcAddress);
          
          const tokenName = await usdcContract.name();
          const tokenSymbol = await usdcContract.symbol();
          const tokenDecimals = await usdcContract.decimals();
          
          console.log("Token Info:", { name: tokenName, symbol: tokenSymbol, decimals: tokenDecimals });
          
          const balance = await usdcContract.balanceOf(userAddress);
          console.log("Balance (raw):", balance.toString());
          
          const formattedBalance = ethers.formatUnits(balance, tokenDecimals);
          console.log("Balance (formatted):", formattedBalance);
          
          document.getElementById("usdcBalanceResult").innerText = 
            `Token: ${tokenName} (${tokenSymbol})\n` +
            `Contract: ${usdcAddress}\n` +
            `Your Address: ${userAddress}\n` +
            `Balance: ${formattedBalance} ${tokenSymbol}\n` +
            `Network: ${network.name} (Chain ID: ${chainId})`;
            
        } catch (error) {
          console.error("Error getting USDC balance:", error);
          document.getElementById("usdcBalanceResult").innerText = 
            `‚ùå Error: ${error.message}\n\n` +
            `Make sure you're connected to a supported network.`;
        }
      }

      async function transferUSDC() {
        try {
          let receiver = document.getElementById("receiverAddress").value;
          let amount = document.getElementById("usdcAmount").value;
          
          document.getElementById("transferResponse").style.display = "none";
          
          if (!receiver || !amount) {
            showTransferMessage("‚ùå Please enter both receiver address and amount", "error");
            return;
          }

          const network = await provider.getNetwork();
          const chainId = network.chainId.toString();
          const usdcAddress = usdcAddresses[chainId];
          
          if (!usdcAddress) {
            showTransferMessage(`‚ùå USDC not available on this network (Chain ID: ${chainId})`, "error");
            return;
          }

          try {
            receiver = ethers.getAddress(receiver);
            console.log("Valid receiver address:", receiver);
          } catch (error) {
            showTransferMessage(`‚ùå Invalid receiver address: ${receiver}`, "error");
            return;
          }

          let parsedAmount;
          try {
            parsedAmount = ethers.parseUnits(amount, 6);
            console.log("Amount in smallest units:", parsedAmount.toString());
            
            if (parsedAmount <= 0n) {
              throw new Error("Amount must be positive");
            }
          } catch (error) {
            showTransferMessage(`‚ùå Invalid amount: ${amount}`, "error");
            return;
          }

          const usdcContract = new ethers.Contract(usdcAddress, usdcABI, signer);

          const balance = await usdcContract.balanceOf(userAddress);
          console.log("Your balance:", balance.toString());
          console.log("Transfer amount:", parsedAmount.toString());

          if (balance < parsedAmount) {
            const amountFormatted = ethers.formatUnits(parsedAmount, 6);
            const balanceFormatted = ethers.formatUnits(balance, 6);
            showTransferMessage(
              `‚ùå Insufficient balance!\n` +
              `You have: ${balanceFormatted} USDC\n` +
              `You need: ${amountFormatted} USDC`,
              "error"
            );
            return;
          }

          const amountFormatted = ethers.formatUnits(parsedAmount, 6);
          showTransferMessage(
            `‚è≥ Transferring ${amountFormatted} USDC to ${receiver.slice(0, 6)}...${receiver.slice(-4)}\n\n` +
            `Please confirm the transaction in MetaMask...`,
            "info"
          );

          console.log("Initiating transfer...");
          const tx = await usdcContract.transfer(receiver, parsedAmount);
          
          console.log("Transaction sent:", tx.hash);
          showTransferMessage(
            `‚è≥ Transaction sent!\n\n` +
            `Hash: ${tx.hash}\n\n` +
            `Waiting for confirmation...`,
            "info"
          );

          const receipt = await tx.wait();
          console.log("Transaction confirmed:", receipt);

          showTransferMessage(
            `‚úÖ Transfer successful!\n\n` +
            `Amount: ${amountFormatted} USDC\n` +
            `To: ${receiver}\n` +
            `Transaction Hash: ${tx.hash}\n` +
            `Block Number: ${receipt.blockNumber}\n` +
            `Gas Used: ${receipt.gasUsed.toString()}`,
            "success"
          );

          document.getElementById("receiverAddress").value = "";
          document.getElementById("usdcAmount").value = "";

          setTimeout(() => {
            getUSDCBalance();
          }, 2000);

        } catch (error) {
          console.error("Error transferring USDC:", error);
          
          let errorMessage = "‚ùå Transfer failed!\n\n";
          
          if (error.code === "ACTION_REJECTED") {
            errorMessage += "Transaction was rejected by user.";
          } else if (error.code === "INSUFFICIENT_FUNDS") {
            errorMessage += "Insufficient ETH for gas fees.";
          } else if (error.message.includes("transfer amount exceeds balance")) {
            errorMessage += "Insufficient USDC balance.";
          } else {
            errorMessage += `Error: ${error.message}`;
          }
          
          showTransferMessage(errorMessage, "error");
        }
      }

      function showTransferMessage(message, type) {
        const transferResponse = document.getElementById("transferResponse");
        transferResponse.innerText = message;
        transferResponse.style.display = "block";
        
        if (type === "error") {
          transferResponse.style.backgroundColor = "#ffebee";
          transferResponse.style.color = "#c62828";
        } else if (type === "success") {
          transferResponse.style.backgroundColor = "#e8f5e9";
          transferResponse.style.color = "#2e7d32";
        } else {
          transferResponse.style.backgroundColor = "#e3f2fd";
          transferResponse.style.color = "#1565c0";
        }
      }

      function disconnectWallet() {
        provider = null;
        signer = null;
        userAddress = null;

        document.getElementById("wallet").innerText = "‚ùå Wallet disconnected from app";
        document.getElementById("network").innerText = "";
        document.getElementById("blockResult").innerText = "";
        document.getElementById("balanceResult").innerText = "";
        document.getElementById("signatureResult").innerText = "";
        document.getElementById("disconnectBtn").style.display = "none";
        document.getElementById("revokeBtn").style.display = "none";

        document.getElementById("addressInput").value = "";
        document.getElementById("messageInput").value = "";

        console.log("Wallet disconnected from app. Refresh the page to reconnect.");
        
        setTimeout(() => {
          if (confirm("Wallet disconnected from app. Do you want to reload the page?")) {
            location.reload();
          }
        }, 1000);
      }

      async function revokePermissions() {
        try {
          if (window.ethereum && window.ethereum.request) {
            await window.ethereum.request({
              method: "wallet_revokePermissions",
              params: [
                {
                  eth_accounts: {}
                }
              ]
            });
            
            console.log("Permissions revoked successfully!");
            alert("‚úÖ MetaMask permissions revoked! The page will reload.");
            
            setTimeout(() => {
              location.reload();
            }, 1000);
          } else {
            throw new Error("MetaMask not available");
          }
        } catch (error) {
          console.error("Error revoking permissions:", error);
          
          if (error.code === -32601) {
            alert(
              "‚ö†Ô∏è Auto-revoke not available in your MetaMask version.\n\n" +
              "To disconnect manually:\n" +
              "1. Click the MetaMask extension\n" +
              "2. Click the three dots (‚ãÆ)\n" +
              "3. Go to 'Connected sites'\n" +
              "4. Disconnect this site"
            );
          } else {
            alert(`Error: ${error.message}`);
          }
        }
      }
    </script>
  </body>
</html>